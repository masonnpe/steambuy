#### Zookeeper分布式锁算法流程：

1. 客户端连接zookeeper，并在锁目录下创建 **临时的** 且 **有序的** 子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推。
2. 客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中 **序号最小**的子节点，如果是则认为获得锁，否则 **监听自己前一位的子节点** ，获得子节点变更通知后判断自己是否时最小子节点直至获得锁；
3. 执行业务代码；
4. 完成业务流程后，删除对应的子节点释放锁。

#### 如何避免死锁

客户端启动的时候，首先会与Zookeeper建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。当客户端故障时，zookeeper将把对应客户端的临时节点删除，这样就不会死锁。

优点：可重入避免死锁;缺点：性能不如缓存锁，吞吐量会随集群增大而降低